# PostgreSQL: Using the EXPLAIN Command

The **EXPLAIN** command in PostgreSQL is used to inspect the **query plan** generated by the Planner component. It helps understand how PostgreSQL intends to execute a query and can be invaluable for performance tuning.

---

## 1. Purpose of EXPLAIN

* Shows the **query plan** without executing the query (unless `ANALYZE` is used).
* Helps identify **bottlenecks** in query execution.
* Can be used with visual tools (e.g., [explain.depesz.com](https://explain.depesz.com)) to make interpretation easier.

**Memory Hook:** “EXPLAIN lets you peek behind the scenes of PostgreSQL’s query execution.”

---

## 2. How EXPLAIN Works

1. The client submits the `EXPLAIN` command along with a SQL query.
2. The query passes through **all query processing stages** **except execution**.
3. The Planner generates a **query plan tree**, which is returned to the client in **textual format**.

---

## 3. EXPLAIN Options

| Option    | Description                                                                 |
| --------- | --------------------------------------------------------------------------- |
| `ANALYZE` | Executes the query and shows **actual run statistics** along with the plan. |
| `COSTS`   | Show or hide **startup and total costs** (default: on).                     |
| `BUFFERS` | Shows buffer usage; works **only with ANALYZE**.                            |
| `FORMAT`  | Output format: `TEXT` (default), `JSON`, `XML`, or `YAML`.                  |
| `VERBOSE` | Prints additional details about plan nodes.                                 |

---

## 4. Understanding Plan Node Output

Each **line in EXPLAIN output** represents a **plan node**. The key details include:

| Field                 | Meaning                                                             |
| --------------------- | ------------------------------------------------------------------- |
| Node Type             | Operation performed (e.g., Seq Scan, Hash Join, Aggregate).         |
| Startup Cost          | Cost before the first row can be returned.                          |
| Total Cost            | Estimated cost to execute the node completely.                      |
| Rows (Estimated)      | Number of rows expected to be returned by the node.                 |
| Actual Rows (ANALYZE) | Number of rows actually returned (if ANALYZE is used).              |
| Loops                 | Number of times this node was executed (relevant for nested loops). |
| Buffers (ANALYZE)     | Number of disk buffers hit/read (if BUFFERS option is on).          |

**Memory Hook:** “Startup cost is the preamble, total cost is the full story.”

---

### 4.1 Cost Explanation

* **Startup Cost:** Effort to prepare the node for returning the first row.

  * Example: Sorting an unindexed column involves pre-sorting before returning rows.
* **Total Cost:** Aggregate cost for the node, including all child nodes in the plan tree.
* **Deviation:** If `ANALYZE` is used, PostgreSQL compares **estimated vs actual** rows.

  * Significant deviation may indicate **outdated statistics**.

---

## 5. Example: Interpreting EXPLAIN Output

* The output is **hierarchical**, representing the plan tree.
* A `->` prefix indicates the node in the tree.
* Example fields: `Node Type`, `Exclusive Time` (time for node itself), `Inclusive Time` (time including child nodes), `Estimated Rows`, `Actual Rows`.

**Tips:**

* **Up arrow:** Planner **overestimated** rows.
* **Down arrow:** Planner **underestimated** rows.
* Large differences → Consider **regenerating table statistics** using `ANALYZE`.

---

## 6. Visualizing Query Plans

* Tools like [explain.depesz.com](https://explain.depesz.com) can **visualize EXPLAIN output**.
* Steps:

  1. Run `EXPLAIN ANALYZE <your_query>` in PostgreSQL.
  2. Copy the output to the tool.
  3. Submit → see **tree layout, costs, rows, and buffer usage** visually.

**Memory Hook:** “Visualization turns textual plans into a clear roadmap of query execution.”

---

## 7. Best Practices

* Always check **estimated vs actual rows** when tuning queries.
* Use **EXPLAIN ANALYZE** to capture real execution statistics.
* Consider **updating statistics** (`ANALYZE table`) if deviations are large.
* Explore **plan nodes** individually to understand operations (e.g., Hash Aggregate, Seq Scan, Nested Loop).

---
```sql
--Query
EXPLAIN (ANALYZE, BUFFERS)
SELECT
    b.bid,
    b.bbalance,
    COUNT(a.aid)    AS account_count,
    SUM(a.abalance) AS total_balance
FROM pgbench_branches b
JOIN pgbench_accounts a
    ON a.bid = b.bid
WHERE a.abalance > 0
GROUP BY b.bid, b.bbalance
ORDER BY total_balance DESC
LIMIT 5;

--Output
"Limit  (cost=218696.56..218696.56 rows=1 width=24) (actual time=2915.437..2915.538 rows=5 loops=1)"
"  Buffers: shared hit=15905 read=149314"
"  ->  Sort  (cost=218696.56..218696.56 rows=1 width=24) (actual time=2915.435..2915.534 rows=5 loops=1)"
"        Sort Key: (sum(a.abalance)) DESC"
"        Sort Method: top-N heapsort  Memory: 25kB"
"        Buffers: shared hit=15905 read=149314"
"        ->  GroupAggregate  (cost=1000.14..218696.55 rows=1 width=24) (actual time=1975.291..2915.212 rows=100 loops=1)"
"              Group Key: b.bid"
"              Buffers: shared hit=15902 read=149314"
"              ->  Nested Loop  (cost=1000.14..218696.53 rows=1 width=16) (actual time=1058.426..2904.942 rows=47917 loops=1)"
"                    Join Filter: (b.bid = a.bid)"
"                    Rows Removed by Join Filter: 4743783"
"                    Buffers: shared hit=15902 read=149314"
"                    ->  Index Scan using pgbench_branches_pkey on pgbench_branches b  (cost=0.14..96.66 rows=100 width=8) (actual time=0.025..0.966 rows=100 loops=1)"
"                          Buffers: shared hit=71 read=11"
"                    ->  Materialize  (cost=1000.00..218598.37 rows=1 width=12) (actual time=0.007..22.683 rows=47917 loops=100)"
"                          Buffers: shared hit=15831 read=149303"
"                          ->  Gather  (cost=1000.00..218598.37 rows=1 width=12) (actual time=0.705..1946.976 rows=47917 loops=1)"
"                                Workers Planned: 2"
"                                Workers Launched: 2"
"                                Buffers: shared hit=15831 read=149303"
"                                ->  Parallel Seq Scan on pgbench_accounts a  (cost=0.00..217598.27 rows=1 width=12) (actual time=0.463..1812.001 rows=15972 loops=3)"
"                                      Filter: (abalance > 0)"
"                                      Rows Removed by Filter: 3317361"
"                                      Buffers: shared hit=15831 read=149303"
"Planning:"
"  Buffers: shared hit=101 read=12"
"Planning Time: 4.097 ms"
"Execution Time: 2916.409 ms"
```

<img width="1658" height="775" alt="image" src="https://github.com/user-attachments/assets/27c7f616-a143-4718-96ea-4b69b1ada722" />
---

## 8. FAQ

**Q1: Does EXPLAIN execute the query?**

* Only if `ANALYZE` is used. Without it, EXPLAIN shows the **planned query**.

**Q2: What do `Startup Cost` and `Total Cost` mean?**

* Startup Cost: Effort to begin returning the first row.
* Total Cost: Total estimated cost for executing the node and its children.

**Q3: How do I know if table statistics are outdated?**

* Large differences between **estimated vs actual rows** indicate that statistics may need regeneration.

**Q4: Can EXPLAIN help with indexing decisions?**

* Yes — the plan shows if PostgreSQL is using **sequential scans, index scans, or joins**, guiding indexing strategies.

