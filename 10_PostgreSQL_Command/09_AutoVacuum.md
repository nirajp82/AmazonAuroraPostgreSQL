# PostgreSQL Autovacuum Configuration and Best Practices

## Overview

Autovacuum is a built-in PostgreSQL background daemon that automatically runs **VACUUM** and **ANALYZE** to keep tables healthy. It helps reclaim space from dead tuples, prevents transaction ID (XID) wraparound, and keeps query planner statistics up to date.

Although autovacuum is **enabled by default**, it is not a ‚Äúset and forget‚Äù feature. Proper configuration and continuous monitoring are critical, especially in production and cloud environments.

---

## How Autovacuum Works

* The **autovacuum daemon** periodically checks table statistics.
* It identifies tables with a high number of **INSERT, UPDATE, and DELETE** operations.
* When predefined **thresholds** are crossed, it launches one or more **autovacuum worker processes**.
* These workers perform **VACUUM** and **ANALYZE** on candidate tables.

Key points:

* Autovacuum is **statistics-driven**, not time-based.
* It can start **at any time**, even during peak load.
* There is **no native scheduling** (for example, ‚Äúonly run at night‚Äù).

If your workload cannot tolerate autovacuum during peak hours, you may:

* Disable autovacuum, and
* Run manual or cron-based vacuum jobs during maintenance windows.

---

## Prerequisites for Autovacuum

Autovacuum relies on table statistics. Therefore:

* `track_counts = on` **must be enabled**
* Without statistics tracking, autovacuum will not trigger

---

## Key Autovacuum Configuration Parameters

> Note: Not all PostgreSQL parameters are available in all managed services (for example, Amazon Aurora). Always check service-specific documentation.

### 1. Autovacuum Daemon Frequency

**`autovacuum_naptime`**

* Controls how often the daemon wakes up to check for candidate tables
* Default: **5 seconds**

Reducing this value makes autovacuum more responsive but increases overhead.

---

### 2. Autovacuum Workers

**`autovacuum_max_workers`**

* Maximum number of autovacuum workers that can run concurrently
* Default: **3**

More workers = faster cleanup, but higher resource usage.

**`autovacuum_work_mem`**

* Memory available to each autovacuum worker
* Limits how much memory vacuum operations can use

---

## Vacuum Trigger Thresholds

Autovacuum decides whether to vacuum a table using **two parameters together**.

### Vacuum Threshold Parameters

* **`autovacuum_vacuum_threshold`** (default: 50)

  * Minimum number of dead tuples required

* **`autovacuum_vacuum_scale_factor`** (default: 0.1)

  * Fraction of table size added to the threshold

### Threshold Formula

```
Vacuum Threshold = autovacuum_vacuum_threshold
                   + (number_of_rows √ó autovacuum_vacuum_scale_factor)
```

### Example

* Total rows in table: **100**
* Dead tuples: **72**
* Threshold calculation:

```
50 + (100 √ó 0.1) = 60
```

Since **72 > 60**, the table becomes a **candidate for vacuuming**.

---

## Analyze Threshold Parameters

Similar parameters exist for **ANALYZE**:

* **`autovacuum_analyze_threshold`** (default: 50)
* **`autovacuum_analyze_scale_factor`** (default: 0.05)

These control when table statistics are refreshed for the query planner.

---

## Autovacuum Cost-Based Throttling

Autovacuum uses a **cost model** to limit its impact on database performance.

### Key Parameters

* **`autovacuum_vacuum_cost_limit`**

  * Maximum cost allowed before the worker sleeps
  * Example (db.r5.large): **200**

* **`autovacuum_vacuum_cost_delay`**

  * Sleep time when cost limit is exceeded
  * Default: **5 ms**

### Important Behavior

* The **cost limit is shared across all autovacuum workers**.
* If you increase `autovacuum_max_workers`, you should also consider increasing `autovacuum_vacuum_cost_limit`.

Otherwise, workers will throttle each other and vacuuming may fall behind.

---

## Transaction ID Wraparound Protection

PostgreSQL databases enter **read-only mode** when transaction IDs approach the wraparound limit.

### CloudWatch Monitoring (Amazon RDS / Aurora)

* CloudWatch publishes **`MaximumUsedTransactionIDs`** metric
* Generated by the RDS/Aurora monitoring agent

### Best Practice

* Create a CloudWatch alarm on:

```
MaximumUsedTransactionIDs > 1,000,000,000
```

(Adjust the threshold based on workload characteristics.)

---

## Responding to XID Alerts

When an alert triggers:

1. Check whether autovacuum is running or failing
2. Identify tables with high dead tuple counts
3. Look for long-running transactions blocking vacuum
4. Terminate blocking transactions if necessary
5. If required:

   * Switch database to read-only mode
   * Run **VACUUM FULL** during maintenance window

---

## Autovacuum Best Practices

### Configuration Tuning

* Keep **autovacuum enabled**
* Make autovacuum more aggressive by:

  * Reducing `autovacuum_naptime`
  * Lowering `autovacuum_vacuum_scale_factor`
  * Increasing `autovacuum_vacuum_cost_limit`
  * Reducing `autovacuum_vacuum_cost_delay`

### Workload Considerations

* Avoid long-running transactions
* Long transactions prevent vacuum from cleaning dead tuples
* Partition large tables with heavy UPDATE/DELETE workloads

### Maintenance Strategy

* If autovacuum is disabled during peak hours:

  * Schedule manual or full vacuum during maintenance windows
  * Monitor vacuum activity closely

### Index Hygiene

* Vacuum also cleans up indexes
* Remove unused or unnecessary indexes to reduce vacuum overhead

---

## Key Takeaways

* Autovacuum is **threshold-based**, not time-based
* Proper tuning depends on table size and workload
* Autovacuum must be **monitored continuously**
* Always monitor **MaximumUsedTransactionIDs** to avoid outages

---

## Memory Hook üß†

**‚ÄúAutovacuum doesn‚Äôt care about time ‚Äî it cares about dead tuples.‚Äù**

If thresholds are too high or vacuum is blocked, the database silently drifts toward performance issues and XID wraparound.

---

## FAQ

**Q: Should I ever disable autovacuum?**
Yes, but only in special cases where workload patterns require strict maintenance windows. Monitoring becomes mandatory.

**Q: Why does autovacuum run during peak load?**
Because it is statistics-driven, not schedule-driven.

**Q: What is the most dangerous autovacuum failure mode?**
Transaction ID wraparound leading to read-only or unavailable database.

**Q: Is increasing workers always good?**
No. You must also increase the shared cost limit, or workers will throttle each other.

**Q: Why does vacuum get blocked?**
Long-running transactions prevent cleanup of dead tuples.
