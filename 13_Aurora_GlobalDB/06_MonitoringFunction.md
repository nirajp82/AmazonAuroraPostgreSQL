# Aurora PostgreSQL Global Database â€“ Monitoring & Metrics

## Overview

This section focuses on **monitoring Amazon Aurora PostgreSQL Global Databases** using **CloudWatch metrics**, **Aurora-provided utility functions**, and **database events**. The goal is to understand **replication lag**, **cross-region data transfer**, and **failover visibility**, so you can assess performance, durability, cost, and readiness for regional failures.

---

## Why Monitoring Matters in Aurora Global Databases (Memory Hook)

**Memory hook:**

> *Global DB monitoring answers three questions:*
> **How far behind is my secondary?** (Lag)
> **How much data am I shipping across regions?** (Cost & throughput)
> **What happens during failover?** (Visibility & automation)

If you remember only one thing:
ðŸ‘‰ *Lag affects RPO, data transfer affects cost, and events tell you what failed and when.*

---

## CloudWatch Metrics for Aurora Global Databases

Aurora Global Databases expose **multiple CloudWatch metrics** specifically for cross-region replication and failover monitoring.

### 1. Aurora Global DB Progress Lag (milliseconds)

**What it measures:**

* How far the **secondary cluster** is behind the **primary cluster**
* Includes **user transactions + system transactions**
* Measured in **milliseconds**

**Key interpretation:**

* Lower values = secondary is closely following the primary
* Spikes usually indicate **write-heavy workloads** or **network delays**

**Important distinction:**

* This metric often changes **less dramatically** than replication lag
* It reflects overall progress, not just transaction application

---

### 2. Aurora Global DB Replication Lag

**What it measures:**

* Replication delay between **primary and secondary regions**

**Observed behavior in tests:**

* During load tests, replication lag showed **noticeable peaks**
* Peaks correlate directly with **write load on the primary cluster**

**Operational takeaway:**

* This is one of the most important metrics for **RPO risk assessment**

---

### 3. Aurora Global DB Data Transfer Bytes

**What it measures:**

* Amount of **Redo log bytes** transferred from primary to secondary region
* Traffic is generated by the **Global DB replicator**

**Why it matters:**

* Used to estimate **cross-region data transfer cost**
* Higher write volume = more redo bytes = higher cost

**Example from the lesson:**

* Initializing a `pgbench` database with **scale factor 100** caused a visible spike

---

### 4. IO Write Count (Primary â†’ Secondary)

**What it measures:**

* Number of write operations replicated from primary to secondary

**Primary use case:**

* Cost analysis for **inter-region replication traffic**
* Helps correlate **write workload** with **data transfer charges**

---

## Practical CloudWatch Usage Notes

* Metrics must be viewed **per region**
* During testing, load generation clearly shows **lag and transfer spikes**
* Always monitor:

  * Replication lag
  * Progress lag
  * Data transfer bytes

---

## Utility Functions for Global Database Monitoring

Aurora provides **SQL utility functions** that give a **point-in-time snapshot** of global database health.

### 1. aurora_global_db_status()

#### Actual Query

```sql
SELECT * FROM aurora_global_db_status();
```

**What this query does:**
Returns a **point-in-time snapshot** of the status of **all clusters** participating in the Aurora Global Database.

**Important columns (explained):**

* **global_cluster_identifier**
  Name of the Aurora Global Database.

* **cluster_identifier**
  Identifier of each regional cluster (primary and secondary).

* **is_writer**
  `true` indicates the primary (writer) cluster.

* **highest_lsn_written**
  Latest WAL (Write-Ahead Log) sequence number generated by the cluster.

* **durable_lsn**
  Highest WAL sequence number safely written to durable storage.

* **durability_lag_ms**
  Time difference (in milliseconds) between:

  * WAL written on primary
  * WAL durably stored on secondary

* **rpo_lag_ms**
  Potential data loss window if a failover happens at this moment.

* **last_updated**
  Timestamp when these values were last calculated.

**How to read the output (Memory Hook):**

> *If durability_lag_ms > 0, the secondary is behind.*

---

**Purpose:**

* Returns the status of **all clusters** in the global database

**Key fields explained:**

* **Highest Log Sequence Number (LSN)**

  * The latest WAL record written on each cluster

* **Durability Lag (milliseconds)**

  * Timestamp difference between:

    * Highest LSN on primary
    * Highest LSN applied on secondary

* **RPO Lag (milliseconds)**

  * Mentioned but explained in a later lecture
  * Represents potential data loss window during failover

**Observed behavior:**

* Running the query repeatedly shows:

  * Changing LSNs
  * Fluctuating durability lag

**Interpretation tip (Memory Hook):**

> *If LSNs differ, the secondary is behind.*

---

### 2. aurora_global_db_instance_status()

#### Actual Query

```sql
SELECT * FROM aurora_global_db_instance_status();
```

**What this query does:**
Returns detailed replication and durability information for **each DB instance** across **all clusters** in the global database.

**Important columns (explained):**

* **db_instance_identifier**
  Unique identifier of the Aurora DB instance.

* **cluster_identifier**
  Indicates which regional cluster the instance belongs to.

* **session_id**
  Internal session identifier for tracking replication state.

* **durable_lsn**
  WAL records that have been fully written to durable storage.

* **highest_lsn_received**
  WAL records received by the instance but not yet fully durable.

* **replication_state**
  Current replication state of the instance.

**Key rule (Very Important):**

* If `highest_lsn_received > durable_lsn` â†’ replication is **still catching up**
* If both values are equal â†’ instance is **fully in sync**

**Operational Tip:**
Run this query repeatedly during load tests to observe real-time replication behavior.

---

**Purpose:**

* Provides status of **all DB instances** across primary and secondary clusters

**Important columns:**

* **DB Instance ID**

  * Unique identifier for each instance

* **Session ID**

  * Internal session tracking per instance

* **Durable Log Sequence Number**

  * WAL records safely written to storage on secondary

* **Highest Log Sequence Number Received**

  * WAL records received but not yet fully durable

**Key rule:**

* If everything is fully synchronized:

  * `Durable LSN == Highest LSN`

**Observed behavior:**

* Highest LSN > Durable LSN â†’ **secondary is lagging**

---

## Load Testing Insight (Important for Learning)

When you:

* Generate write load (e.g., `pgbench`)
* Query the utility functions repeatedly

You will observe:

* Rapid changes in lag values
* LSN differences growing and shrinking

**This is expected behavior.**
It directly reflects how much write pressure you are applying.

---

## Monitoring Global Database Events

Aurora emits **events specific to global database failures**.

### Key Event Categories

* Global failover initiated
* Instances shutting down
* Parameter adjustments
* Promotion of secondary cluster to primary

These events can be viewed from:

* **RDS Console â†’ Events** (left navigation)

---

## Using Events for Automation (Conceptual)

Users can:

* Subscribe to global DB events
* Trigger automation (covered in later exercises)

**Typical automation use cases:**

* Application endpoint updates
* Traffic routing changes
* Alerting and incident handling

---

## Failover Monitoring Considerations (Very Important)

**Monitoring settings are NOT inherited by the secondary cluster**

This means:

* Enhanced Monitoring must be enabled **per instance**
* Performance Insights must be enabled **per region**
* CloudWatch alarms must be recreated in secondary region
* Any automation must be deployed in **both primary and secondary clusters**

**Memory Hook:**

> *Failover changes roles, not configurations.*

---

## Key Takeaways (Quick Refresh)

* Aurora Global DB exposes **specialized CloudWatch metrics**
* Replication lag and progress lag are **not the same**
* Data transfer metrics help estimate **cross-region cost**
* Utility functions provide **point-in-time visibility**
* Events are critical for **failover awareness and automation**
* Monitoring features **do not automatically move** to secondary

---

## FAQ

### Q1: Which metric should I monitor most closely?

**Replication Lag** and **Progress Lag** â€” these directly affect RPO and application consistency.

---

### Q2: Why does Progress Lag change less than Replication Lag?

Progress Lag includes **system-level progress**, while Replication Lag focuses more directly on transaction application delay.

---

### Q3: Why do my monitoring alarms disappear after failover?

Because **monitoring is not inherited**. You must configure alarms separately in each region.

---

### Q4: Why is Highest LSN greater than Durable LSN?

This indicates WAL records were received but **not yet fully written to durable storage** on the secondary.

---

### Q5: Can I rely only on CloudWatch metrics?

No. CloudWatch gives trends; **utility functions give precise point-in-time state**. Use both.

---

### Q6: Does high data transfer always mean a problem?

No. It usually means **high write workload**, but it does affect **cross-region cost**.

---

### Q7: Is RPO lag the same as replication lag?

No. RPO lag represents **potential data loss window during failover**, which is related but conceptually different.

---

## Memory Summary (One-Line Recall)

> *Lag shows risk, transfer shows cost, functions show truth, and events show failure.*
