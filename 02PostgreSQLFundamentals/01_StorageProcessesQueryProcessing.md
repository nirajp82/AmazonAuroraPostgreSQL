# Postgres SQL Internal Architecture & Operations Guide

## 1. Data Storage & Persistence

Understanding how Postgres manages data on the physical disk.

* **File System Storage:** Data for tables and indexes is persisted on the file system of the attached storage.
* **File Structure:** Data may be spread across one or more data files. The maximum size of a single data file is **1 GB**.
* **Pages (Blocks):** Inside these files, data is read and written in chunks known as **Pages** or **Blocks**. The default size of a block is **8KB**.

## 2. Process Architecture

How the server handles connections and manages processes.

* **The Postmaster Process:** This is the parent of all processes in the Postgres cluster.
  - It implements the **TCP Listener** (default port: `5432`).
  - It manages the startup and shutdown of the database.

* **Backend Processes:** When a client connects to the Postmaster, it "forks" (creates) a dedicated **Backend Process**.
  - This process handles all queries and statements for that specific client.
  - There is a one-to-one relationship: **1 Client = 1 Backend Process**.
    
<img width="1377" height="726" alt="image" src="https://github.com/user-attachments/assets/f54227fc-349b-49c7-835b-0c596e5ee7d1" />


* **Max Connections:** The maximum number of backend processes is controlled by the configuration parameter `max_connections`. This limit depends on available CPU, memory, and network resources.

## 3. The Life of a Query

When a backend process receives a query, it goes through **five distinct stages**.

1. **Parser:**
* Receives the SQL text.
* Checks syntax and converts it into a tree-like structure called the **Parse Tree**.


2. **Analyzer:**
* Takes the Parse Tree and adds semantic information (e.g., checking if tables/columns exist).
* Transforms it into a **Query Tree**.


3. **Rewriter:**
* Applies rules (like Views) to transform parts of the Query Tree.
* Passes the modified tree to the Planner.


4. **Planner (Optimizer):**
* Generates **Query Execution Instructions** (The Plan).
* It uses statistics (row counts, data distribution) to find the most efficient path to the data.


5. **Executor:**
* Follows the instructions in the plan.
* Retrieves the data and sends the result set back to the client.

<img width="1089" height="593" alt="image" src="https://github.com/user-attachments/assets/27c0518e-ebe9-41b4-8a9e-5f5db29dfc65" />

## 4. Statistics & Optimization

To ensure the **Planner** makes good decisions, it needs accurate data about the database.

* **Stats Collector Process:** A background process responsible for gathering statistics on database objects (tables, indexes).
* **The `ANALYZE` Command:** Users can run this command to manually update statistics, ensuring the Planner has up-to-date info.
* **The `EXPLAIN` Command:** Users can run this to see the execution plan generated by the Planner (useful for debugging performance).
<img width="1429" height="429" alt="image" src="https://github.com/user-attachments/assets/aa975b0b-9a02-4100-97e7-551d5e3b64e1" />

## 5. Memory Management & Caching

Postgres uses memory to minimize slow disk I/O operations.

* **Shared Buffers (Buffer Pool):**
  * A large chunk of memory dedicated to caching **8KB data pages**.
  * Controlled by the parameter `shared_buffers`.
  * **How it works:** The Executor first checks if data is in the Shared Buffers.
    * *If found:* Data is read from memory (fast).
    * *If not found:* Data is read from storage into the buffer, then passed to the executor.

* **Local Memory:** Each backend process also has its own dedicated memory for specific tasks:
  * `work_mem`: Used for sorting data and hash tables.
  * `maintenance_work_mem`: Used for maintenance tasks like `REINDEX` or `VACUUM`.

<img width="1805" height="941" alt="image" src="https://github.com/user-attachments/assets/9d725c6a-aa4f-4e51-8c76-31b9001099ce" />



## 6. Performance Metrics: Buffer Cache Hit Ratio

One of the most important metrics for database performance is the **Buffer Cache Hit Ratio**.

* **Definition:** It measures how often the database finds the data it needs in memory (RAM) versus reading it from the disk.
* **The Formula:**

The Formula:

$$\text{Hit Ratio} = \frac{\text{Blocks Read from Buffer}}{\text{Blocks Read from Buffer} + \text{Blocks Read from Disk}}$$

* **Interpretation:** The higher the ratio, the better the performance. A high ratio (ideally > 99%) indicates that the `shared_buffers` pool is effectively caching frequently accessed data.
* Shared Buffers are an in-memory cached copy (replica) of data file pages from disk. All reads and writes happen against this in-memory copy

---

## 7. Monitoring Script

Use the following SQL script to check your current Buffer Cache Hit Ratio.

```sql
-- Check Buffer Cache Hit Ratio
SELECT 
  sum(heap_blks_read) as heap_read,
  sum(heap_blks_hit)  as heap_hit,
  sum(heap_blks_hit) / (sum(heap_blks_hit) + sum(heap_blks_read)) as ratio
FROM 
  pg_statio_user_tables;

```

**Script Key:**

* `heap_read`: Physical reads from disk.
* `heap_hit`: Reads from the memory buffer.
* `ratio`: The calculated efficiency percentage.

---

### **Summary Checklist**

* [ ] **Storage:** Data is split into 1GB files and 8KB pages.
* [ ] **Processes:** Postmaster listens; Backend processes execute queries.
* [ ] **Query Flow:** Parse  Analyze  Rewrite  Plan  Execute.
* [ ] **Tuning:** Keep stats updated with `ANALYZE`; check plans with `EXPLAIN`.
* [ ] **Caching:** Monitor Hit Ratio using the provided script and tune `shared_buffers` accordingly.
