## Overview

Amazon RDS for PostgreSQL supports **logical replication** by streaming **Write-Ahead Log (WAL)** changes using **logical replication slots**. This allows you to capture and stream database changes to external systems (not necessarily replicas), such as AWS DMS or custom consumers running on EC2.

Logical replication works at a **database level** and allows **table-level replication**, making it suitable for migrations, integrations, and change data capture (CDC) use cases.

---

## Memory Hook üß†

Think of **logical replication** as:

> **"PostgreSQL tells what changed in the table instead of copying the whole data."**

* Physical replication = copies blocks
* Logical replication = streams **row-level changes**

---

## Key Concepts

### Aurora PostgreSQL: WAL vs Redo Log (Important Clarification)

A common point of confusion is whether **Aurora PostgreSQL uses WAL or redo logs**. The correct answer is: **both exist, but at different layers**.

#### Memory Hook üß†

> **PostgreSQL thinks in WAL. Aurora stores changes as redo logs.**

You interact with **WAL**. Aurora internally manages **redo logs**.

### PostgreSQL Engine Layer (What You See)

* Aurora PostgreSQL **still generates WAL records**
* WAL is used for:

  * Crash recovery logic
  * Logical replication
  * Streaming replication
  * Logical decoding (`wal2json`, `test_decoding`)
* WAL-related settings still apply:

  * `wal_level`
  * `pg_replication_slots`
  * `pg_recvlogical`

Logical replication in Aurora **reads decoded WAL**, exactly like standard PostgreSQL.

### Aurora Storage Layer (What AWS Manages)

* Aurora **does not store traditional WAL files on local disk**
* WAL records are:

  * Converted into **redo log records**
  * Sent over the network
  * Persisted across **6 copies in 3 AZs**
* Storage nodes apply redo records directly to data pages

This distributed redo log design makes Aurora:

* Faster at replication
* More durable
* Able to recover without replaying large WAL files

### Why Logical Replication Still Works

* It consumes WAL **before it reaches the storage layer**
* Does not depend on Aurora‚Äôs internal redo log storage
* Key points:

  * Logical replication slots work because Aurora PostgreSQL still generates WAL at the engine level.
  * AWS DMS works because it reads decoded WAL through logical replication slots.
  * If a replication slot is created but no client reads from it, WAL is retained and storage can grow.

### Summary Table

| Aspect                      | Standard PostgreSQL | Aurora PostgreSQL |
| --------------------------- | ------------------- | ----------------- |
| WAL generated by engine     | Yes                 | Yes               |
| WAL visible to users        | Yes                 | Yes               |
| WAL stored as files         | Yes                 | No                |
| Redo log in storage layer   | No                  | Yes               |
| Logical replication support | Yes                 | Yes               |

---

## End-to-End Logical Replication: WAL ‚Üí Replication Slot ‚Üí Subscriber

### 1Ô∏è‚É£ Write-Ahead Log (WAL)

* WAL records every change in PostgreSQL (INSERT, UPDATE, DELETE).
* Think of it as a diary of all changes.
* Logical replication reads WAL entries to stream changes to other systems.
* WAL is **not deleted until all interested replication slots have consumed it**.

**Memory Hook üß†:**

> ‚ÄúPostgreSQL writes down every change before committing it ‚Äî WAL is its diary.‚Äù

**Key Concept:**

> Once WAL is consumed by a subscriber (through a replication slot), PostgreSQL can **free the old WAL** to reclaim storage. If no subscriber reads it, WAL piles up and storage can grow.

### 2Ô∏è‚É£ Logical Replication Slot

* A replication slot is like a **bookmark or pointer** in the WAL.
* It **remembers how much WAL has been read** by each subscriber.
* **Created per database**, not per table.
* Slots **do not know who is reading** ‚Äî they only ensure WAL isn‚Äôt deleted until consumed.

**Important Notes:**

* If no one reads from a slot, WAL **accumulates indefinitely**, which can fill storage.
* Aurora PostgreSQL still generates WAL at the engine layer; slots work normally even though Aurora stores data as redo logs internally.
* If a subscriber consumes WAL, the slot moves forward, and old WAL is freed (space reclaimed).
* **One slot = one active reader at a time.** Multiple subscribers require **separate slots**. WAL is retained until **all slots** consuming it have processed the records.

**Memory Hook üß†:**

> ‚ÄúReplication slot = ‚ÄòHold my WAL until someone reads it.‚Äô‚Äù

**Analogy:**

> WAL = mailbox; Slot = marker on last letter read; Consumed letters are removed, unread letters pile up.

### 3Ô∏è‚É£ Logical Decoding

* Converts raw WAL into **readable change events**.
* Uses output plugins:

  * `test_decoding` ‚Üí simple text, good for debugging
  * `wal2json` ‚Üí JSON, good for CDC pipelines or AWS DMS

**Memory Hook üß†:**

> ‚ÄúLogical decoding = translating WAL diary entries into a language the subscriber can understand.‚Äù

### 4Ô∏è‚É£ Publisher and Subscriber

* **Publisher:** Source database producing changes.

  * Creates **publications** (tables to replicate).
  * Creates **logical replication slots** to track WAL consumption.
* **Subscriber:** Target database or app receiving changes.

  * Creates **subscriptions** pointing to the publisher.
  * Reads WAL via replication slot using logical decoding.
  * Applies changes to target tables to stay in sync.
* **Slot creation:** Can be done manually on the publisher, or auto-created when the subscriber creates the subscription.
* **Multiple subscribers:** Each must have its own replication slot; WAL is retained until all slots have consumed it.

**Memory Hook üß†:**

> ‚ÄúPublisher says: ‚ÄòHere‚Äôs the WAL diary.‚Äô Subscriber says: ‚ÄòI‚Äôll read your diary through my slot.‚Äô‚Äù

### 5Ô∏è‚É£ End-to-End Step-by-Step Flow

1. **Publisher** creates table(s) and publication.
2. PostgreSQL writes changes to WAL when tables are updated.
3. **Replication slot** is created on the publisher: ‚ÄúHold my WAL for the subscriber.‚Äù (Optional if subscriber auto-creates)
4. **Subscriber** creates subscription pointing to the publisher.
5. **Logical decoding** translates WAL into readable changes.
6. **Subscriber reads WAL** through the replication slot.
7. **Changes are applied** to subscriber‚Äôs target tables.
8. **Slot keeps track** of consumed WAL.
9. **If subscriber stops reading**, WAL is retained and storage grows.
10. **If multiple subscribers exist**, each must have its own slot; WAL is retained until **all slots** have consumed it.

**Memory Hook üß†:**

> ‚ÄúIf WAL is consumed by the subscriber, it‚Äôs gone; if not, it keeps piling up. Each subscriber needs its own slot.‚Äù

### 6Ô∏è‚É£ Quick Diagram (Text)

```
[Publisher DB] -- WAL generated --> [Replication Slot A] --decoded--> [Subscriber A DB]
                  -- WAL generated --> [Replication Slot B] --decoded--> [Subscriber B DB]
      |                                                         ^
      |                                                         |
      |----------------- Publication --------------------------|
```

**Analogy:**

* WAL = mailbox of changes
* Slot = bookmark in mailbox
* Subscriber = reader consuming letters
* Unread letters = WAL retention risk
* Multiple readers = multiple slots, WAL freed only when all have read

### 7Ô∏è‚É£ Key Takeaways

* **WAL:** source of truth for changes; cannot be deleted until consumed by all relevant slots.
* **Replication slot:** bookmark/pointer for WAL; ensures subscribers don‚Äôt miss changes.
* **One slot = one active reader; multiple readers require multiple slots.**
* **Logical decoding:** translates WAL ‚Üí readable changes.
* **Publication:** set of tables to replicate (publisher).
* **Subscription:** config to consume WAL (subscriber).
* **End-to-end:** WAL ‚Üí Slot ‚Üí Decode ‚Üí Subscriber ‚Üí Apply.

---

## Common Logical Replication Clients

* **AWS Database Migration Service (DMS)**
* Custom consumers using:

  * `pg_recvlogical`
  * Custom applications on EC2

‚ö†Ô∏è The target **does not need to be a replica database**.

---

## Enabling Logical Replication on RDS PostgreSQL

### Required Roles

* `rds_superuser` ‚Üí to enable logical replication
* `rds_replication` ‚Üí to manage replication slots and stream data

### Required Parameter Changes

* `rds.logical_replication = 1` (static)
* `wal_level = logical`
* `max_wal_senders`
* `max_replication_slots`
* `max_connections`

‚ö†Ô∏è These settings **increase WAL generation**. Enable them **only when needed**.
üîÅ **DB reboot required** for `rds.logical_replication` to take effect.

---

Absolutely! Let‚Äôs add a **dedicated section** for **Understanding Logical Replication and Logical Decoding** with all the key details you just mentioned. I‚Äôll make it beginner-friendly and keep it consistent with the rest of your README.

---

## Understanding Logical Replication and Logical Decoding

Amazon RDS for PostgreSQL supports **streaming database changes** using:

* **Logical replication slots** ‚Üí track WAL changes
* **Logical decoding** ‚Üí converts WAL changes into readable formats

This allows you to stream changes to a client such as `pg_recvlogical`, AWS DMS, or a custom-managed host on an EC2 instance.

**Key Points:**

* **Slots are per database:** Each slot supports replication connections to a single database.
* **Slots don‚Äôt know the client:** They simply hold WAL changes until a subscriber reads them.
* **Target doesn‚Äôt need to be a replica:** You can stream changes to any database or application.
* **WAL accumulation risk:** If you create a slot but no client reads from it, WAL keeps piling up and can fill your storage.

---

### Enabling Logical Replication and Decoding on RDS

To enable logical replication and decoding:

1. **Roles required:**

   * `rds_superuser` ‚Üí to enable logical replication
   * `rds_replication` ‚Üí to manage replication slots and stream data

2. **Parameter changes:**

   * `rds.logical_replication = 1` (static)
   * Also configure: `wal_level`, `max_wal_senders`, `max_replication_slots`, `max_connections`
   * ‚ö†Ô∏è These changes increase WAL generation. Enable only when using logical slots.

3. **Reboot required:**

   * After changing `rds.logical_replication`, the DB instance must be rebooted for the changes to take effect.

---

### Creating a Logical Replication Slot

* You must specify a **decoding plugin** when creating a slot.
* Supported plugins in RDS for PostgreSQL:

  * `test_decoding` ‚Üí simple, human-readable (good for learning/debugging)
  * `wal2json` ‚Üí JSON output (commonly used for CDC pipelines and AWS DMS)

Example:

```sql
SELECT * FROM pg_create_logical_replication_slot('test_slot', 'test_decoding');
```

* Verify slots:

```sql
SELECT * FROM pg_replication_slots;
```

* Drop a slot when no longer needed:

```sql
SELECT pg_drop_replication_slot('test_slot');
```

**Memory Hook üß†:**

> ‚ÄúCreate a slot ‚Üí PostgreSQL holds WAL until someone reads it. No slot ‚Üí WAL can be discarded after commit.‚Äù

---

## Streaming Changes Using pg_recvlogical

```bash
pg_recvlogical -d postgres --slot test_slot -U postgres \
--host <instance-endpoint> \
-f - --start
```

Requirements:

* Replication connection allowed
* Proper authentication configured

---

## Replicating Table-Level Data (Logical Replication)

### Step 1: Create Source Table

```sql
CREATE TABLE testtab (slno int PRIMARY KEY);
INSERT INTO testtab VALUES (generate_series(1,1000));
```

### Step 2: Create Publication (Source DB)

```sql
CREATE PUBLICATION testpub FOR TABLE testtab;
SELECT * FROM pg_publication;
SELECT * FROM pg_publication_tables;
```

Replicate all tables:

```sql
CREATE PUBLICATION testpub FOR ALL TABLES;
```

Add new table to existing publication:

```sql
ALTER PUBLICATION testpub ADD TABLE new_table;
```

### Step 3: Create Target Table (Target DB)

```sql
CREATE TABLE testtab (slno int PRIMARY KEY);
SELECT count(*) FROM testtab;
```

### Step 4: Create Subscription (Target DB)

```sql
CREATE SUBSCRIPTION testsub
CONNECTION 'host=<source-endpoint> port=5432 dbname=<source_db> user=<user> password=<password>'
PUBLICATION testpub;
SELECT oid, subname, subenabled, subslotname, subpublications FROM pg_subscription;
```

### Initial Data Load

* Subscription creation automatically copies existing data and starts streaming.

```sql
SELECT count(*) FROM testtab;
```

### Replication Slot Verification (Source DB)

```sql
SELECT * FROM pg_replication_slots;
```

* `slot_type = logical`
* `active = true`
* `confirmed_flush_lsn` tracks consumer progress

### Testing Replication

```sql
INSERT INTO testtab VALUES (generate_series(1001,2000));
SELECT count(*) FROM testtab; -- Source
SELECT count(*) FROM testtab; -- Target
```

### Refreshing Subscription After Adding Tables

```sql
ALTER SUBSCRIPTION testsub REFRESH PUBLICATION;
```

### Common Pitfalls ‚ö†Ô∏è

| Issue                                                      | What Happens                                                                                                                            | How to Fix / Prevent                                                          |
| ---------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------- |
| **Leaving logical slots unused**                           | If a replication slot exists but no subscriber reads from it, WAL keeps piling up, consuming storage until the slot is read or dropped. | Drop unused slots or ensure subscribers read regularly                        |
| **Forgetting to refresh subscription after adding tables** | If you add new tables to a publication, the subscriber won‚Äôt see them; changes to new tables aren‚Äôt replicated.                         | Run `ALTER SUBSCRIPTION <sub> REFRESH PUBLICATION` after adding tables        |
| **Schema mismatch between source and target**              | Column types, names, or constraints don‚Äôt match; replication errors or failed inserts/updates occur.                                    | Ensure source and target tables match in column names, types, and constraints |
| **Insufficient replication slots or WAL senders**          | If you run out of available slots or WAL sender connections, new subscriptions can‚Äôt start, and replication may fail or stall.          | Increase `max_replication_slots` and `max_wal_senders` in DB parameters       |

---

## FAQ

**Q1:** Is logical replication the same as read replicas?

* No. Logical replication works at **table/row level**, while read replicas use **physical replication**.

**Q2:** Does the target have to be PostgreSQL?

* No. Logical replication streams changes; the consumer can transform or load data elsewhere.

**Q3:** What happens if the consumer stops reading?

* WAL accumulates and can **exhaust storage**.

**Q4:** Can I replicate only specific tables?

* Yes, using **publications**.

**Q5:** Is a reboot required?

* Yes, when enabling `rds.logical_replication`.

**Q6:** Which plugin should I use?

* `test_decoding` ‚Üí learning/debugging
* `wal2json` ‚Üí production CDC pipelines

**Q7:** Why does DMS work?

* DMS reads decoded WAL through the replication slot, independent of Aurora storage layer.

**Q8:** Why do logical replication slots work?

* Because PostgreSQL engine still produces WAL, which slots can track reliably.

**Q9:** Can multiple subscribers share one slot?

* No; each subscriber requires its own slot, and WAL is retained until all slots have consumed it.

---

## Quick Mental Summary üß†

**Enable ‚Üí Create Slot ‚Üí Publish Tables ‚Üí Subscribe ‚Üí Stream Changes**
