## Overview

Amazon RDS for PostgreSQL supports **logical replication** by streaming **Write-Ahead Log (WAL)** changes using **logical replication slots**. This allows you to capture and stream database changes to external systems (not necessarily replicas), such as AWS DMS or custom consumers running on EC2.

Logical replication works at a **database level** and allows **table-level replication**, making it suitable for migrations, integrations, and change data capture (CDC) use cases.

---

## Memory Hook üß†

Think of **logical replication** as:

> **"PostgreSQL tells what changed in the table instead of copying the whole data."**

* Physical replication = copies blocks
* Logical replication = streams **row-level changes**

---

## Key Concepts

---

## Aurora PostgreSQL: WAL vs Redo Log (Important Clarification)

A common point of confusion is whether **Aurora PostgreSQL uses WAL or redo logs**. The correct answer is: **both exist, but at different layers**.

### Memory Hook üß†

> **PostgreSQL thinks in WAL. Aurora stores changes as redo logs.**

You interact with **WAL**. Aurora internally manages **redo logs**.

### PostgreSQL Engine Layer (What You See)

* Aurora PostgreSQL **still generates WAL records**
* WAL is used for:

  * Crash recovery logic
  * Logical replication
  * Streaming replication
  * Logical decoding (`wal2json`, `test_decoding`)
* WAL-related settings still apply:

  * `wal_level`
  * `pg_replication_slots`
  * `pg_recvlogical`

Logical replication in Aurora **reads decoded WAL**, exactly like standard PostgreSQL.

### Aurora Storage Layer (What AWS Manages)

* Aurora **does not store traditional WAL files on local disk**
* Instead, WAL records are:

  * Converted into **redo log records**
  * Sent over the network
  * Persisted across **6 copies in 3 AZs**
* Storage nodes apply redo records directly to data pages

This distributed redo log design is what makes Aurora:

* Faster at replication
* More durable
* Able to recover without replaying large WAL files

### Why Logical Replication Still Works

Logical replication happens **before** data reaches the storage layer:

* It consumes WAL from the PostgreSQL engine
* It does not depend on how Aurora stores data internally

That‚Äôs why:

 - **Logical replication slots work because Aurora PostgreSQL still generates WAL at the database engine level, which slots can safely track and consume.**
 - **AWS DMS works because it reads decoded WAL changes from PostgreSQL logical replication slots, not from Aurora‚Äôs internal storage layer.**
 - **If a replication slot is created but no client reads from it, PostgreSQL keeps the WAL instead of deleting it, which can cause storage growth. In other words, ‚ÄúLogical replication slots prevent WAL cleanup. If the consumer stops reading, WAL is retained indefinitely, which can cause storage growth.‚Äù**

### Summary Table

| Aspect                      | Standard PostgreSQL | Aurora PostgreSQL |
| --------------------------- | ------------------- | ----------------- |
| WAL generated by engine     | Yes                 | Yes               |
| WAL visible to users        | Yes                 | Yes               |
| WAL stored as files         | Yes                 | No                |
| Redo log in storage layer   | No                  | Yes               |
| Logical replication support | Yes                 | Yes               |

---

## End-to-End Logical Replication: WAL ‚Üí Replication Slot ‚Üí Subscriber

### 1Ô∏è‚É£ Write-Ahead Log (WAL)

* WAL records every change in PostgreSQL (INSERT, UPDATE, DELETE).
* Think of it as a diary of all changes.
* Logical replication reads WAL entries to stream changes to other systems.
* WAL is **not deleted until all interested replication slots have consumed it**.

**Memory Hook üß†:**

> ‚ÄúPostgreSQL writes down every change before committing it ‚Äî WAL is its diary.‚Äù

**Key Concept:**

> Once WAL is consumed by a subscriber (through a replication slot), PostgreSQL can **free the old WAL** to reclaim storage. If no subscriber reads it, WAL piles up and storage can grow.

---

### 2Ô∏è‚É£ Logical Replication Slot

* A replication slot is like a **bookmark or pointer** in the WAL.
* It **remembers how much WAL has been read** by each subscriber.
* **Created per database**, not per table.
* Slots **do not know who is reading** ‚Äî they only ensure WAL isn‚Äôt deleted until consumed.

**Important Notes:**

* If no one reads from a slot, WAL **accumulates indefinitely**, which can fill storage.
* Aurora PostgreSQL still generates WAL at the engine layer; slots work normally even though Aurora stores data as redo logs internally.
* If a subscriber consumes WAL, the slot moves forward, and old WAL is freed (space reclaimed).
* **One slot = one active reader at a time.** Multiple subscribers require **separate slots**. WAL is retained until **all slots** consuming it have processed the records.

**Memory Hook üß†:**

> ‚ÄúReplication slot = ‚ÄòHold my WAL until someone reads it.‚Äô‚Äù

**Analogy:**

> WAL = mailbox; Slot = marker on last letter read; Consumed letters are removed, unread letters pile up.

---

### 3Ô∏è‚É£ Logical Decoding

* Converts raw WAL into **readable change events**.
* Uses output plugins:

  * `test_decoding` ‚Üí simple text, good for debugging
  * `wal2json` ‚Üí JSON, good for CDC pipelines or AWS DMS

**Memory Hook üß†:**

> ‚ÄúLogical decoding = translating WAL diary entries into a language the subscriber can understand.‚Äù

---

### 4Ô∏è‚É£ Publisher and Subscriber

* **Publisher:** Source database producing changes.

  * Creates **publications** (tables to replicate).
  * Creates **logical replication slots** to track WAL consumption.
* **Subscriber:** Target database or app receiving changes.

  * Creates **subscriptions** pointing to the publisher.
  * Reads WAL via replication slot using logical decoding.
  * Applies changes to target tables to stay in sync.
* **Slot creation:** Can be done manually on the publisher, or auto-created when the subscriber creates the subscription.
* **Multiple subscribers:** Each must have its own replication slot; WAL is retained until all slots have consumed it.

**Memory Hook üß†:**

> ‚ÄúPublisher says: ‚ÄòHere‚Äôs the WAL diary.‚Äô
> Subscriber says: ‚ÄòI‚Äôll read your diary through my slot.‚Äô‚Äù

---

### 5Ô∏è‚É£ End-to-End Step-by-Step Flow

1. **Publisher** creates table(s) and publication.
2. PostgreSQL writes changes to WAL when tables are updated.
3. **Replication slot** is created on the publisher: ‚ÄúHold my WAL for the subscriber.‚Äù (Optional if subscriber auto-creates)
4. **Subscriber** creates subscription pointing to the publisher.
5. **Logical decoding** translates WAL into readable changes.
6. **Subscriber reads WAL** through the replication slot.
7. **Changes are applied** to subscriber‚Äôs target tables.
8. **Slot keeps track** of consumed WAL.
9. **If subscriber stops reading**, WAL is retained and storage grows.
10. **If multiple subscribers exist**, each must have its own slot; WAL is retained until **all slots** have consumed it.

**Memory Hook üß†:**

> ‚ÄúIf WAL is consumed by the subscriber, it‚Äôs gone; if not, it keeps piling up. Each subscriber needs its own slot.‚Äù

---

### 6Ô∏è‚É£ Quick Diagram (Text)

```
[Publisher DB] -- WAL generated --> [Replication Slot A] --decoded--> [Subscriber A DB]
                  -- WAL generated --> [Replication Slot B] --decoded--> [Subscriber B DB]
      |                                                         ^
      |                                                         |
      |----------------- Publication --------------------------|
```

**Analogy:**

* WAL = mailbox of changes
* Slot = bookmark in mailbox
* Subscriber = reader consuming letters
* Unread letters = WAL retention risk
* Multiple readers = multiple slots, WAL freed only when all have read

---

### 7Ô∏è‚É£ Key Takeaways

* **WAL:** source of truth for changes; cannot be deleted until consumed by all relevant slots.
* **Replication slot:** bookmark/pointer for WAL; ensures subscribers don‚Äôt miss changes.
* **One slot = one active reader; multiple readers require multiple slots.**
* **Logical decoding:** translates WAL ‚Üí readable changes.
* **Publication:** set of tables to replicate (publisher).
* **Subscription:** config to consume WAL (subscriber).
* **End-to-end:** WAL ‚Üí Slot ‚Üí Decode ‚Üí Subscriber ‚Üí Apply.

---

### FAQ / Common Pitfalls

* **What happens if no one reads a slot?** ‚Üí WAL piles up and can fill storage.
* **Do I need to create the slot manually?** ‚Üí Optional; subscription can auto-create.
* **Why does Aurora use redo logs?** ‚Üí WAL is still generated by PostgreSQL engine; Aurora stores data as redo logs internally for distributed storage efficiency.
* **Why does DMS work?** ‚Üí DMS reads decoded WAL through the replication slot, independent of Aurora storage layer.
* **Why do logical replication slots work?** ‚Üí Because PostgreSQL engine still produces WAL, which slots can track reliably.
* **Can multiple subscribers share one slot?** ‚Üí No; each subscriber requires its own slot, and WAL is retained until all slots have consumed it.


---

## Common Logical Replication Clients

* **AWS Database Migration Service (DMS)**
* Custom consumers using:

  * `pg_recvlogical`
  * Custom applications on EC2

‚ö†Ô∏è The target **does not need to be a replica database**.

---

## Enabling Logical Replication on RDS PostgreSQL

### Required Roles

The user must have:

* `rds_superuser` ‚Üí to enable logical replication
* `rds_replication` ‚Üí to manage replication slots and stream data

---

### Required Parameter Changes

Set the following parameters:

* `rds.logical_replication = 1` (static)
* `wal_level = logical`
* `max_wal_senders`
* `max_replication_slots`
* `max_connections`

‚ö†Ô∏è These settings **increase WAL generation**. Enable them **only when needed**.

üîÅ **DB reboot required** for `rds.logical_replication` to take effect.

---

## Working with Logical Replication Slots

### Create a Logical Slot

```sql
SELECT * FROM pg_create_logical_replication_slot('test_slot', 'test_decoding');
```

### List Existing Slots

```sql
SELECT * FROM pg_replication_slots;
```

### Drop a Logical Slot

```sql
SELECT pg_drop_replication_slot('test_slot');
```

‚ö†Ô∏è Always drop unused slots to avoid WAL bloat.

---

## Streaming Changes Using pg_recvlogical

`pg_recvlogical` is a PostgreSQL client tool used to consume logical replication streams.

Example:

```bash
pg_recvlogical -d postgres --slot test_slot -U postgres \
--host <instance-endpoint> \
-f - --start
```

Requirements:

* Replication connection allowed
* Proper authentication configured

---

## Replicating Table-Level Data (Logical Replication)

Logical replication allows **table-by-table replication** using **publications** and **subscriptions**.

---

## Step 1: Create Source Table

```sql
CREATE TABLE testtab (slno int PRIMARY KEY);
```

Insert data:

```sql
INSERT INTO testtab VALUES (generate_series(1,1000));
```

---

## Step 2: Create Publication (Source DB)

Create publication:

```sql
CREATE PUBLICATION testpub FOR TABLE testtab;
```

Verify publication:

```sql
SELECT * FROM pg_publication;
```

Verify tables:

```sql
SELECT * FROM pg_publication_tables;
```

### Replicate All Tables

```sql
CREATE PUBLICATION testpub FOR ALL TABLES;
```

### Add New Table to Existing Publication

```sql
ALTER PUBLICATION testpub ADD TABLE new_table;
```

---

## Step 3: Create Target Table

(Target DB must have matching schema)

```sql
CREATE TABLE testtab (slno int PRIMARY KEY);
```

Verify target is empty:

```sql
SELECT count(*) FROM testtab;
```

---

## Step 4: Create Subscription (Target DB)

```sql
CREATE SUBSCRIPTION testsub
CONNECTION 'host=<source-endpoint> port=5432 dbname=<source_db> user=<user> password=<password>'
PUBLICATION testpub;
```

Verify subscription:

```sql
SELECT oid, subname, subenabled, subslotname, subpublications FROM pg_subscription;
```

---

## Initial Data Load

* Subscription creation automatically:

  * Copies existing data
  * Starts streaming ongoing changes

Verify initial load:

```sql
SELECT count(*) FROM testtab;
```

---

## Replication Slot Verification (Source DB)

```sql
SELECT * FROM pg_replication_slots;
```

Important fields:

* `slot_type = logical`
* `active = true`
* `confirmed_flush_lsn` tracks consumer progress

---

## Testing Replication

Insert new data in source:

```sql
INSERT INTO testtab VALUES (generate_series(1001,2000));
```

Verify source:

```sql
SELECT count(*) FROM testtab;
```

Verify target:

```sql
SELECT count(*) FROM testtab;
```

‚úÖ Counts should match.

---

## Refreshing Subscription After Adding Tables

When new tables are added to a publication, you **must refresh the subscription**:

```sql
ALTER SUBSCRIPTION testsub REFRESH PUBLICATION;
```

What this does:

* Fetches new table metadata
* Starts replication for newly added tables

---

## Common Pitfalls ‚ö†Ô∏è

* Leaving logical slots unused ‚Üí **disk fills up**
* Forgetting to refresh subscription after adding tables
* Schema mismatch between source and target
* Insufficient replication slots or WAL senders

---

## FAQ

### Q1: Is logical replication the same as read replicas?

No. Logical replication works at **table/row level**, while read replicas use **physical replication**.

### Q2: Does the target have to be PostgreSQL?

No. Logical replication streams changes; the consumer can transform or load data elsewhere.

### Q3: What happens if the consumer stops reading?

WAL accumulates and can **exhaust storage**.

### Q4: Can I replicate only specific tables?

Yes, using **publications**.

### Q5: Is a reboot required?

Yes, when enabling `rds.logical_replication`.

### Q6: Which plugin should I use?

* `test_decoding` ‚Üí learning/debugging
* `wal2json` ‚Üí production CDC pipelines

---

## Quick Mental Summary üß†

**Enable ‚Üí Create Slot ‚Üí Publish Tables ‚Üí Subscribe ‚Üí Stream Changes**
