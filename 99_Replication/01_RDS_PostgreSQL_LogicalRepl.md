## Overview

Amazon RDS for PostgreSQL supports **logical replication** by streaming **Write-Ahead Log (WAL)** changes using **logical replication slots**. This allows you to capture and stream database changes to external systems (not necessarily replicas), such as AWS DMS or custom consumers running on EC2.

Logical replication works at a **database level** and allows **table-level replication**, making it suitable for migrations, integrations, and change data capture (CDC) use cases.

---

## Memory Hook üß†

Think of **logical replication** as:

> **"PostgreSQL tells what changed in the table instead of copying the whole data."**

* Physical replication = copies blocks
* Logical replication = streams **row-level changes**

---

## Key Concepts

### Aurora PostgreSQL: WAL vs Redo Log (Important Clarification)

A common point of confusion is whether **Aurora PostgreSQL uses WAL or redo logs**. The correct answer is: **both exist, but at different layers**.

#### Memory Hook üß†

> **PostgreSQL thinks in WAL. Aurora stores changes as redo logs.**

You interact with **WAL**. Aurora internally manages **redo logs**.

### PostgreSQL Engine Layer (What You See)

* Aurora PostgreSQL **still generates WAL records**
* WAL is used for:

  * Crash recovery logic
  * Logical replication
  * Streaming replication
  * Logical decoding (`wal2json`, `test_decoding`)
* WAL-related settings still apply:

  * `wal_level`
  * `pg_replication_slots`
  * `pg_recvlogical`

Logical replication in Aurora **reads decoded WAL**, exactly like standard PostgreSQL.

### Aurora Storage Layer (What AWS Manages)

* Aurora **does not store traditional WAL files on local disk**
* WAL records are:

  * Converted into **redo log records**
  * Sent over the network
  * Persisted across **6 copies in 3 AZs**
* Storage nodes apply redo records directly to data pages

This distributed redo log design makes Aurora:

* Faster at replication
* More durable
* Able to recover without replaying large WAL files

### Why Logical Replication Still Works

* It consumes WAL **before it reaches the storage layer**
* Does not depend on Aurora‚Äôs internal redo log storage
* Key points:

  * Logical replication slots work because Aurora PostgreSQL still generates WAL at the engine level.
  * AWS DMS works because it reads decoded WAL through logical replication slots.
  * If a replication slot is created but no client reads from it, WAL is retained and storage can grow.

### Summary Table

| Aspect                      | Standard PostgreSQL | Aurora PostgreSQL |
| --------------------------- | ------------------- | ----------------- |
| WAL generated by engine     | Yes                 | Yes               |
| WAL visible to users        | Yes                 | Yes               |
| WAL stored as files         | Yes                 | No                |
| Redo log in storage layer   | No                  | Yes               |
| Logical replication support | Yes                 | Yes               |

---

## End-to-End Logical Replication: WAL ‚Üí Replication Slot ‚Üí Subscriber

### 1Ô∏è‚É£ Write-Ahead Log (WAL)

* WAL records every change in PostgreSQL (INSERT, UPDATE, DELETE).
* Think of it as a diary of all changes.
* Logical replication reads WAL entries to stream changes to other systems.
* WAL is **not deleted until all interested replication slots have consumed it**.

**Memory Hook üß†:**

> ‚ÄúPostgreSQL writes down every change before committing it ‚Äî WAL is its diary.‚Äù

**Key Concept:**

> Once WAL is consumed by a subscriber (through a replication slot), PostgreSQL can **free the old WAL** to reclaim storage. If no subscriber reads it, WAL piles up and storage can grow.

### 2Ô∏è‚É£ Logical Replication Slot

* A replication slot is like a **bookmark or pointer** in the WAL.
* It **remembers how much WAL has been read** by each subscriber.
* **Created per database**, not per table.
* Slots **do not know who is reading** ‚Äî they only ensure WAL isn‚Äôt deleted until consumed.

**Important Notes:**

* If no one reads from a slot, WAL **accumulates indefinitely**, which can fill storage.
* Aurora PostgreSQL still generates WAL at the engine layer; slots work normally even though Aurora stores data as redo logs internally.
* If a subscriber consumes WAL, the slot moves forward, and old WAL is freed (space reclaimed).
* **One slot = one active reader at a time.** Multiple subscribers require **separate slots**. WAL is retained until **all slots** consuming it have processed the records.

**Memory Hook üß†:**

> ‚ÄúReplication slot = ‚ÄòHold my WAL until someone reads it.‚Äô‚Äù

**Analogy:**

> WAL = mailbox; Slot = marker on last letter read; Consumed letters are removed, unread letters pile up.

### 3Ô∏è‚É£ Logical Decoding

* Converts raw WAL into **readable change events**.
* Uses output plugins:

  * `test_decoding` ‚Üí simple text, good for debugging
  * `wal2json` ‚Üí JSON, good for CDC pipelines or AWS DMS

**Memory Hook üß†:**

> ‚ÄúLogical decoding = translating WAL diary entries into a language the subscriber can understand.‚Äù

### 4Ô∏è‚É£ Publisher and Subscriber

* **Publisher:** Source database producing changes.

  * Creates **publications** (tables to replicate).
  * Creates **logical replication slots** to track WAL consumption.
* **Subscriber:** Target database or app receiving changes.

  * Creates **subscriptions** pointing to the publisher.
  * Reads WAL via replication slot using logical decoding.
  * Applies changes to target tables to stay in sync.
* **Slot creation:** Can be done manually on the publisher, or auto-created when the subscriber creates the subscription.
* **Multiple subscribers:** Each must have its own replication slot; WAL is retained until all slots have consumed it.

**Memory Hook üß†:**

> ‚ÄúPublisher says: ‚ÄòHere‚Äôs the WAL diary.‚Äô Subscriber says: ‚ÄòI‚Äôll read your diary through my slot.‚Äô‚Äù

### 5Ô∏è‚É£ End-to-End Step-by-Step Flow

1. **Publisher** creates table(s) and publication.
2. PostgreSQL writes changes to WAL when tables are updated.
3. **Replication slot** is created on the publisher: ‚ÄúHold my WAL for the subscriber.‚Äù (Optional if subscriber auto-creates)
4. **Subscriber** creates subscription pointing to the publisher.
5. **Logical decoding** translates WAL into readable changes.
6. **Subscriber reads WAL** through the replication slot.
7. **Changes are applied** to subscriber‚Äôs target tables.
8. **Slot keeps track** of consumed WAL.
9. **If subscriber stops reading**, WAL is retained and storage grows.
10. **If multiple subscribers exist**, each must have its own slot; WAL is retained until **all slots** have consumed it.

**Memory Hook üß†:**

> ‚ÄúIf WAL is consumed by the subscriber, it‚Äôs gone; if not, it keeps piling up. Each subscriber needs its own slot.‚Äù

### 6Ô∏è‚É£ Quick Diagram (Text)

```
[Publisher DB] -- WAL generated --> [Replication Slot A] --decoded--> [Subscriber A DB]
                  -- WAL generated --> [Replication Slot B] --decoded--> [Subscriber B DB]
      |                                                         ^
      |                                                         |
      |----------------- Publication --------------------------|
```

**Analogy:**

* WAL = mailbox of changes
* Slot = bookmark in mailbox
* Subscriber = reader consuming letters
* Unread letters = WAL retention risk
* Multiple readers = multiple slots, WAL freed only when all have read

### 7Ô∏è‚É£ Key Takeaways

* **WAL:** source of truth for changes; cannot be deleted until consumed by all relevant slots.
* **Replication slot:** bookmark/pointer for WAL; ensures subscribers don‚Äôt miss changes.
* **One slot = one active reader; multiple readers require multiple slots.**
* **Logical decoding:** translates WAL ‚Üí readable changes.
* **Publication:** set of tables to replicate (publisher).
* **Subscription:** config to consume WAL (subscriber).
* **End-to-end:** WAL ‚Üí Slot ‚Üí Decode ‚Üí Subscriber ‚Üí Apply.

---

## Common Logical Replication Clients

* **AWS Database Migration Service (DMS)**
* Custom consumers using:

  * `pg_recvlogical`
  * Custom applications on EC2

‚ö†Ô∏è The target **does not need to be a replica database**.

---

## Enabling Logical Replication on RDS PostgreSQL

### Required Roles

* `rds_superuser` ‚Üí to enable logical replication
* `rds_replication` ‚Üí to manage replication slots and stream data

### Required Parameter Changes

* `rds.logical_replication = 1` (static)
* `wal_level = logical`
* `max_wal_senders`
* `max_replication_slots`
* `max_connections`

‚ö†Ô∏è These settings **increase WAL generation**. Enable them **only when needed**.
üîÅ **DB reboot required** for `rds.logical_replication` to take effect.

---

Absolutely! Let‚Äôs add a **dedicated section** for **Understanding Logical Replication and Logical Decoding** with all the key details you just mentioned. I‚Äôll make it beginner-friendly and keep it consistent with the rest of your README.

---

## Understanding Logical Replication and Logical Decoding

Amazon RDS for PostgreSQL supports **streaming database changes** using:

* **Logical replication slots** ‚Üí track WAL changes
* **Logical decoding** ‚Üí converts WAL changes into readable formats

This allows you to stream changes to a client such as `pg_recvlogical`, AWS DMS, or a custom-managed host on an EC2 instance.

**Key Points:**

* **Slots are per database:** Each slot supports replication connections to a single database.
* **Slots don‚Äôt know the client:** They simply hold WAL changes until a subscriber reads them.
* **Target doesn‚Äôt need to be a replica:** You can stream changes to any database or application.
* **WAL accumulation risk:** If you create a slot but no client reads from it, WAL keeps piling up and can fill your storage.

---

### Enabling Logical Replication and Decoding on RDS

To enable logical replication and decoding:

1. **Roles required:**

   * `rds_superuser` ‚Üí to enable logical replication
   * `rds_replication` ‚Üí to manage replication slots and stream data

2. **Parameter changes:**

   * `rds.logical_replication = 1` (static)
   * Also configure: `wal_level`, `max_wal_senders`, `max_replication_slots`, `max_connections`
   * ‚ö†Ô∏è These changes increase WAL generation. Enable only when using logical slots.

3. **Reboot required:**

   * After changing `rds.logical_replication`, the DB instance must be rebooted for the changes to take effect.

---

Here‚Äôs a **refined, logically organized, beginner-friendly version** of that section for your README. I‚Äôve kept all your details, removed clutter, and added small explanations where helpful:

---

## Working with Logical Replication Slots

Logical replication slots are **bookmarks in the WAL** that track how much data has been consumed by a subscriber. You can manage them using SQL commands.

### 1Ô∏è‚É£ Create a Logical Slot

Example: create a logical slot named `test_slot` using the `test_decoding` plugin:

```sql
SELECT * FROM pg_create_logical_replication_slot('test_slot', 'test_decoding');
```

Output:

```
slot_name       | xlog_position
----------------+---------------
test_slot       | 0/16B1970
(1 row)
```

---

### 2Ô∏è‚É£ List Existing Slots

```sql
SELECT * FROM pg_replication_slots;
```

This shows active slots, their type, plugin, and progress.

---

### 3Ô∏è‚É£ Drop a Logical Slot

```sql
SELECT pg_drop_replication_slot('test_slot');
```

‚ö†Ô∏è **Always drop unused slots** to avoid WAL accumulation and storage issues.

---

### 4Ô∏è‚É£ Streaming Changes Using `pg_recvlogical`

Once a slot is created, you can start streaming WAL changes. `pg_recvlogical` is a PostgreSQL tool that reads WAL changes from a slot:

```bash
pg_recvlogical -d postgres --slot test_slot -U postgres \
    --host <instance-endpoint> \
    -f - --start
```

* Requires **replication permissions** (`rds_replication` role).
* Streams changes decoded by the plugin (`test_decoding` or `wal2json`) to stdout, file, or another consumer.

---

### 5Ô∏è‚É£ Checking Replication Origin Status

```sql
SELECT * FROM pg_show_replication_origin_status();
```

Output columns:

* `local_id` | `external_id` | `remote_lsn` | `local_lsn`
* Tracks the progress of replication origins (used internally for logical replication).

---

## Replicating Table-Level Data Using Logical Replication

Logical replication allows **table-by-table replication**. It performs an **initial load** of existing data and then streams **ongoing changes**.

### Step 1: Create Source Table

Connect to the source database:

```sql
CREATE TABLE testtab (slno int PRIMARY KEY);
INSERT INTO testtab VALUES (generate_series(1,1000));
```

### Step 2: Create a Publication

```sql
CREATE PUBLICATION testpub FOR TABLE testtab;
```

Verify the publication:

```sql
SELECT * FROM pg_publication;
SELECT * FROM pg_publication_tables;
```

* To replicate all tables:

```sql
CREATE PUBLICATION testpub FOR ALL TABLES;
```

* To add a new table to an existing publication:

```sql
ALTER PUBLICATION testpub ADD TABLE new_table;
```

### Step 3: Create Target Table

Connect to the target database and create the table(s) with the same schema:

```sql
CREATE TABLE testtab (slno int PRIMARY KEY);
SELECT count(*) FROM testtab; -- Should be 0 initially
```

### Step 4: Create Subscription (Target DB)

```sql
CREATE SUBSCRIPTION testsub
CONNECTION 'host=<source-endpoint> port=5432 dbname=<source_db> user=<user> password=<password>'
PUBLICATION testpub;
```

Verify subscription:

```sql
SELECT oid, subname, subenabled, subslotname, subpublications
FROM pg_subscription;
```

* Subscription **automatically creates a replication slot** on the publisher if it doesn‚Äôt exist.
* Initial data from source tables is **copied to target tables**.

```sql
SELECT count(*) FROM testtab; -- Should match source table
```

### Step 5: Verify Replication Slot (Source DB)

```sql
SELECT * FROM pg_replication_slots;
```

* Shows slot name, plugin, type, active status, and LSN positions.
* Confirm `active = true` and `slot_type = logical`.

### Step 6: Test Replication

Insert new rows in the source table:

```sql
INSERT INTO testtab VALUES (generate_series(1001,2000));
SELECT count(*) FROM testtab; -- 2000 rows
```

Verify the target table:

```sql
SELECT count(*) FROM testtab; -- 2000 rows
```

### Step 7: Refresh Subscription After Adding Tables

If you add new tables to a publication, the subscription **must be refreshed**:

```sql
ALTER SUBSCRIPTION testsub REFRESH PUBLICATION;
```

* Ensures newly added tables are replicated.
* Pulls missing table info from the publisher and starts replication for those tables.

‚úÖ **Key Notes:**

* **Slots track WAL consumption**; subscribers must read regularly to avoid storage growth.
* **Schema must match** between source and target tables.
* **Multiple subscribers** require separate slots; WAL is retained until all slots have consumed it.
* `pg_recvlogical` can be used for testing, debugging, or custom CDC pipelines.

---

### Common Pitfalls ‚ö†Ô∏è

| Issue                                                      | What Happens                                                                                                                            | How to Fix / Prevent                                                          |
| ---------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------- |
| **Leaving logical slots unused**                           | If a replication slot exists but no subscriber reads from it, WAL keeps piling up, consuming storage until the slot is read or dropped. | Drop unused slots or ensure subscribers read regularly                        |
| **Forgetting to refresh subscription after adding tables** | If you add new tables to a publication, the subscriber won‚Äôt see them; changes to new tables aren‚Äôt replicated.                         | Run `ALTER SUBSCRIPTION <sub> REFRESH PUBLICATION` after adding tables        |
| **Schema mismatch between source and target**              | Column types, names, or constraints don‚Äôt match; replication errors or failed inserts/updates occur.                                    | Ensure source and target tables match in column names, types, and constraints |
| **Insufficient replication slots or WAL senders**          | If you run out of available slots or WAL sender connections, new subscriptions can‚Äôt start, and replication may fail or stall.          | Increase `max_replication_slots` and `max_wal_senders` in DB parameters       |

---

## FAQ

Here‚Äôs a **refined and fully integrated FAQ** for your README, combining all the earlier questions, clarifications, and `pg_recvlogical` details. I‚Äôve removed duplicates, ensured clarity, and added missing points based on our discussion:

---

## FAQ: Logical Replication, WAL, Slots, and `pg_recvlogical`

**Q1: Is logical replication the same as read replicas?**

* No. Logical replication works at **table/row level**, while read replicas use **physical replication**.

**Q2: Does the target have to be PostgreSQL?**

* No. Logical replication streams changes; the consumer can transform or load data elsewhere.

**Q3: What happens if the consumer stops reading?**

* WAL accumulates in the replication slot and can **exhaust storage**. Unread WAL is retained until the slot is read or dropped.

**Q4: Can I replicate only specific tables?**

* Yes, using **publications**. You can also add tables to an existing publication and refresh subscriptions to start replication for new tables.

**Q5: Is a reboot required?**

* Yes, when enabling the static parameter `rds.logical_replication` in RDS PostgreSQL.

**Q6: Which logical decoding plugin should I use?**

* `test_decoding` ‚Üí simple, human-readable output for learning or debugging.
* `wal2json` ‚Üí JSON output, suitable for production CDC pipelines and integrations like DMS.

**Q7: Why does AWS DMS work with Aurora PostgreSQL?**

* DMS reads **decoded WAL** from replication slots at the PostgreSQL engine level, independent of Aurora‚Äôs internal redo log storage.

**Q8: Why do logical replication slots work?**

* Because PostgreSQL **always generates WAL**, and slots reliably track consumption, ensuring subscribers don‚Äôt miss changes.

**Q9: Can multiple subscribers share one slot?**

* No. Each subscriber requires its own replication slot. WAL is retained until **all slots** consuming it have read it.

**Q10: What is `pg_recvlogical`?**

* A PostgreSQL **command-line tool** that reads WAL changes from a logical replication slot, acting as a subscriber or consumer.

**Q11: Is `pg_recvlogical` the same as a replication slot?**

* No. A **replication slot is the bookmark**, while `pg_recvlogical` is the **client that reads WAL using that slot**.

**Q12: What permissions are needed to use `pg_recvlogical`?**

* The connecting user must have **replication privileges**, typically via the `rds_replication` role.

**Q13: What does `pg_recvlogical` do with WAL?**

* Streams WAL changes decoded by a plugin (`test_decoding` or `wal2json`) to a file, stdout, or another consumer. Once WAL is read, the replication slot moves forward, freeing old WAL.

**Q14: Can multiple clients read from the same slot using `pg_recvlogical`?**

* **No.** Each slot supports **one active reader at a time**. Multiple subscribers require **separate slots**.

**Q15: What are common use cases for `pg_recvlogical`?**

* Debugging or learning SQL changes (`test_decoding`).
* Building custom CDC pipelines (`wal2json`).
* Testing logical replication manually.
* Integration with external systems like AWS DMS (as a lower-level alternative).

**Q16: Do I need to create a slot manually before using `pg_recvlogical`?**

* Yes, unless your subscriber or tool (like DMS) auto-creates it. Example:

```sql
SELECT * FROM pg_create_logical_replication_slot('test_slot', 'test_decoding');
```

**Q17: What happens if a replication slot is unused?**

* WAL continues to accumulate, consuming storage. Always drop unused slots or ensure subscribers read regularly.

**Q18: Why is schema matching important?**

* Source and target tables must have matching **column names, types, and constraints**. Mismatches can cause replication errors or failed inserts/updates.

**Q19: What if I run out of replication slots or WAL senders?**

* New subscriptions cannot start, and replication may fail or stall. Increase `max_replication_slots` and `max_wal_senders` in DB parameters if needed.

---

‚úÖ **Key Takeaways:**

* WAL is always generated; logical replication **reads it using slots**.
* Replication slots = bookmarks that retain WAL until subscribers read it.
* `pg_recvlogical` is a client that reads WAL for testing, debugging, or custom CDC pipelines.
* Multiple subscribers ‚Üí multiple slots. Unread WAL ‚Üí storage risk.
* Proper schema, slot management, and parameter tuning are critical for reliable logical replication.

---

## Quick Mental Summary üß†

**Enable ‚Üí Create Slot ‚Üí Publish Tables ‚Üí Subscribe ‚Üí Stream Changes**
